# 03. Lambda and H-O Functions

repo: https://github.com/eljay0921/toy-projects/tree/main/java-kotlin-project

---

## (1) Lambda 선언 

### java

```java
// 함수형 인터페이스 정의
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

@FunctionalInterface
interface Printer {
    void print(String message);
}

// 사용
public class LambdaExample {
    public static void main(String[] args) {
        // 람다 표현식
        Calculator add = (a, b) -> a + b;
        Calculator multiply = (a, b) -> a * b;
        
        System.out.println(add.calculate(5, 3));      // 8
        System.out.println(multiply.calculate(5, 3)); // 15
        
        // 여러 줄 람다
        Calculator complexCalc = (a, b) -> {
            int result = a + b;
            result *= 2;
            return result;
        };
        
        // 매개변수가 없는 람다
        Runnable task = () -> System.out.println("Hello");
        
        // 매개변수가 하나인 람다
        Printer printer = message -> System.out.println(message);
    }
}
```

### kotlin

```kotlin
// 함수형 인터페이스 필요 없음! 함수 타입 직접 사용
fun main() {
    // 람다 표현식
    val add: (Int, Int) -> Int = { a, b -> a + b }
    val multiply = { a: Int, b: Int -> a * b }  // 타입 추론
    
    println(add(5, 3))      // 8
    println(multiply(5, 3)) // 15
    
    // 여러 줄 람다 (마지막 표현식이 반환값)
    val complexCalc = { a: Int, b: Int ->
        val result = a + b
        result * 2  // return 키워드 없이 반환
    }
    
    // 매개변수가 없는 람다
    val task: () -> Unit = { println("Hello") }
    
    // 매개변수가 하나인 람다 - it 사용
    val printer: (String) -> Unit = { println(it) }
    
    // 명시적으로 이름 지정도 가능
    val printerWithName: (String) -> Unit = { message -> 
        println(message) 
    }
}
```

### 📝 주요 차이점

- **함수형 인터페이스 불필요**: `(Int, Int) -> Int` 같은 함수 타입 직접 사용
- **it 키워드**: 단일 매개변수 람다에서 자동 생성
- **마지막 표현식이 자동 반환**: `return` 키워드 생략 가능

---

## (2) 고차 함수

### java

```java
// 함수를 매개변수로 받는 메서드
public class HigherOrderExample {
    // 고차 함수 정의
    public static int operation(int a, int b, Calculator calc) {
        return calc.calculate(a, b);
    }
    
    // 함수를 반환하는 메서드
    public static Calculator getOperation(String type) {
        switch (type) {
            case "add":
                return (a, b) -> a + b;
            case "multiply":
                return (a, b) -> a * b;
            default:
                return (a, b) -> 0;
        }
    }
    
    public static void main(String[] args) {
        // 람다를 인자로 전달
        int result1 = operation(10, 5, (a, b) -> a + b);
        int result2 = operation(10, 5, (a, b) -> a * b);
        
        System.out.println(result1);  // 15
        System.out.println(result2);  // 50
        
        // 함수를 반환받아 사용
        Calculator adder = getOperation("add");
        System.out.println(adder.calculate(7, 3));  // 10
    }
}
```

### kotlin

```kotlin
// 함수를 매개변수로 받는 함수
fun operation(a: Int, b: Int, calc: (Int, Int) -> Int): Int {
    return calc(a, b)
}

// 더 간결하게
fun operation(a: Int, b: Int, calc: (Int, Int) -> Int) = calc(a, b)

// 함수를 반환하는 함수
fun getOperation(type: String): (Int, Int) -> Int {
    return when (type) {
        "add" -> { a, b -> a + b }
        "multiply" -> { a, b -> a * b }
        else -> { _, _ -> 0 }
    }
}

fun main() {
    // 람다를 인자로 전달
    val result1 = operation(10, 5) { a, b -> a + b }
    val result2 = operation(10, 5) { a, b -> a * b }
    
    println(result1)  // 15
    println(result2)  // 50
    
    // 함수를 반환받아 사용
    val adder = getOperation("add")
    println(adder(7, 3))  // 10
}
```

### 📝 주요 차이점

- **Trailing lambda**: 마지막 매개변수가 람다면 괄호 밖으로 빼낼 수 있음
- **함수 타입이 일급 시민**: 더 자연스러운 함수형 프로그래밍

---

## (2) Collection 처리

### java (stream)

```java
import java.util.*;
import java.util.stream.*;

public class CollectionExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // filter: 짝수만 선택
        List<Integer> evenNumbers = numbers.stream()
            .filter(n -> n % 2 == 0)
            .collect(Collectors.toList());
        
        // map: 각 요소를 제곱
        List<Integer> squared = numbers.stream()
            .map(n -> n * n)
            .collect(Collectors.toList());
        
        // filter + map 조합
        List<Integer> evenSquared = numbers.stream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * n)
            .collect(Collectors.toList());
        
        // reduce: 합계 구하기
        int sum = numbers.stream()
            .reduce(0, (a, b) -> a + b);
        
        // forEach: 각 요소 출력
        numbers.stream()
            .forEach(n -> System.out.println(n));
        
        // 복잡한 예제: 짝수의 제곱의 합
        int result = numbers.stream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * n)
            .reduce(0, Integer::sum);
        
        System.out.println(result);  // 220
    }
}
```

### kotlin

```kotlin
fun main() {
    val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    
    // filter: 짝수만 선택
    val evenNumbers = numbers.filter { it % 2 == 0 }
    
    // map: 각 요소를 제곱
    val squared = numbers.map { it * it }
    
    // filter + map 조합
    val evenSquared = numbers
        .filter { it % 2 == 0 }
        .map { it * it }
    
    // reduce: 합계 구하기
    val sum = numbers.reduce { acc, n -> acc + n }
    // 또는 더 간단하게
    val sum2 = numbers.sum()
    
    // forEach: 각 요소 출력
    numbers.forEach { println(it) }
    
    // 복잡한 예제: 짝수의 제곱의 합
    val result = numbers
        .filter { it % 2 == 0 }
        .map { it * it }
        .sum()
    
    println(result)  // 220
    
    // 추가: any, all, none
    val hasEven = numbers.any { it % 2 == 0 }      // true
    val allPositive = numbers.all { it > 0 }       // true
    val noNegative = numbers.none { it < 0 }       // true
}
```

### 📝 주요 차이점

- **stream() 불필요**: 컬렉션에 직접 고차 함수 적용
- **collect() 불필요**: 자동으로 새 컬렉션 반환
- **훨씬 간결한 문법**: `it` 키워드와 간단한 메서드 호출

---

