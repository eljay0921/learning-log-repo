# k8s basic 01 - get started
#dev/skill/container/k8s

## 강의<!-- {"fold":true} -->
[온라인 강의 - 자신의 일정에 맞춰 뭐든지 배워보세요](https://www.udemy.com/course/kubernetes-training-learn-kubernetes-from-zero-to-cloud/learn/lecture/45002009#overview)<!-- {"preview":"true"} -->

## 내용 정리
### 1. 클라우드 네이티브와 마이크로서비스
* **2015년**부터 *클라우드 네이티브*라는 용어가 유행하기 시작했음.
* 클라우드 네이티브 앱은 **마이크로서비스** 아키텍처 기반으로 설계 → 단일 모놀리식 구조 대신, 여러 개의 작은 서비스로 분리.
* 각 마이크로서비스는 **컨테이너** 안에서 실행되며, 필요한 의존성과 자원만 포함해 **경량화**됨.
* 컨테이너는 환경에 상관없이 (개인 PC, 클라우드 등) 동일하게 실행 가능 → 이식성과 확장성 확보.

### 2. 마이크로서비스 관리의 어려움
* 마이크로서비스가 많아질수록 **관리 복잡성** 증가:
  * **리소스 할당**: CPU/메모리를 효율적으로 분배하는 문제.
  * **복원력**: 장애 발생 시 자동으로 컨테이너를 재시작할 방법 필요.
  * **로드 밸런싱**: 트래픽 폭주 시 자동 확장 및 부하 분산 필요.
* 컨테이너 배포 자체는 쉽지만, **대규모 관리와 오케스트레이션**이 어려운 부분.

### 3. 구글 Borg와 쿠버네티스의 등장
* **2014년 구글**: 연간 20억 개 컨테이너 운영 → 내부 툴 *Borg* 사용.
* Borg는 확장, 복원력, 자원 관리, 로드밸런싱 등을 자동화.
* 이를 기반으로 **쿠버네티스(Kubernetes)**를 오픈소스로 공개 → 이후 사실상 표준(de facto standard)이 됨.

### 4. 쿠버네티스 기본 구조
* **노드(Node)**: 쿠버네티스 클러스터를 구성하는 물리/가상 머신.
* **마스터 노드(Control Plane)**: 언제, 어디서 컨테이너가 실행될지 결정.
* **워커 노드**: 실제로 컨테이너를 실행하는 머신.
* **파드(Pod)**: 쿠버네티스의 최소 배포 단위. 컨테이너는 반드시 파드 안에서 실행됨.

### 5. 선언적 구성(Declarative Approach)
* 사용자는 **구성 파일(YAML 등)**로 앱 이름, 이미지, 자원(CPU/메모리)을 선언.
* 쿠버네티스가 이를 해석해 배포/자원 할당/유지보수를 자동 수행.
* 핵심: 사용자는 *“무엇을 원하는지”*만 정의, 세부 구현은 쿠버네티스가 처리.

### 6. 서비스와 네트워킹
* 파드에는 **가상 IP**가 부여되지만, 파드는 **일시적(휘발성)**이라 IP가 자주 바뀜.
* 이를 해결하기 위해 **서비스(Service)** 개념 제공:
  * 특정 라벨(label)을 가진 파드들을 묶어 안정적으로 접근 가능.
  * 동시에 **로드 밸런서** 역할 수행 → 여러 파드에 트래픽을 균등 분산.

### 7. 스토리지 오케스트레이션
* DB 같은 경우, 스토리지 수동 관리가 복잡.
* 쿠버네티스는 **PVC(Persistent Volume Claim)**으로 스토리지 자동 할당.
* 어떤 클라우드(AWS, Azure, GCP)든 관계없이 동일하게 동작 → **벤더 종속성(vendor lock-in) 해소**.

### 8. 결론
* 쿠버네티스는 단순히 컨테이너 실행이 아니라,
  * 서비스 디스커버리
  * 로드 밸런싱
  * 자원 관리
  * 스토리지 관리
  * 장애 복구 및 자동화 등을 전부 지원.
* 따라서 개발자는 **앱 개발에만 집중**하고, 운영 복잡성은 쿠버네티스가 해결.
* 이 때문에 쿠버네티스가 클라우드의 **사실상 표준 도구**가 됨.

## 📌 핵심 한 줄 요약
쿠버네티스는 컨테이너 기반 마이크로서비스를 **확장·관리·자동화**해주는 오케스트레이션 플랫폼으로, 복잡한 운영 부담을 덜어주며 클라우드 환경에서 사실상 표준으로 자리잡았다.
