# 02. Basics

repo: https://github.com/eljay0921/toy-projects/tree/main/java-kotlin-project

---

## (1) 변수 선언

### java

```java
// 기본 타입
int number = 10;
String name = "John";
boolean isActive = true;
double price = 99.99;

// 상수
final String CONSTANT = "HELLO";
final List<String> list = new ArrayList<>();

// 타입 추론 (Java 10+)
var userName = "Alice";  // String으로 추론
var count = 42;          // int로 추론

// Null 허용
String nullableString = null;  // 컴파일 시점에 null 체크 없음
```

### kotlin

```kotlin
// 불변 변수 (val = value, 읽기 전용)
val number = 10           // Int로 추론
val name = "John"         // String으로 추론
val isActive = true       // Boolean으로 추론
val price = 99.99         // Double로 추론

// 가변 변수 (var = variable)
var userName = "Alice"
var count = 42

// 명시적 타입 선언
val explicitString: String = "Hello"
val explicitInt: Int = 100

// 상수 (컴파일 타임 상수)
const val CONSTANT = "HELLO"  // 최상위 레벨이나 object에서만 사용

// Null 안전성
val nonNullString: String = "Hello"        // null 불가
val nullableString: String? = null         // null 허용
// val error: String = null                // 컴파일 에러!
```

### 주요 차이점

- **val**: 불변 (Java의 final과 유사하지만 더 간단)
- **var**: 가변
- **타입 추론이 더 강력**: 대부분의 경우 타입 생략 가능
- **Null safety**: `?`를 통해 명시적으로 null 허용 여부 표현

---

## (2) 함수 선언

### java

```java
// 기본 메서드
public int add(int a, int b) {
    return a + b;
}

// void 메서드
public void printMessage(String message) {
    System.out.println(message);
}

// 오버로딩
public String greet(String name) {
    return "Hello, " + name;
}

public String greet(String name, String title) {
    return "Hello, " + title + " " + name;
}

// 정적 메서드
public static int multiply(int a, int b) {
    return a * b;
}

// 기본값 처리 (메서드 오버로딩으로)
public void createUser(String name) {
    createUser(name, 18, true);  // 기본값 하드코딩
}

public void createUser(String name, int age, boolean isActive) {
    // 실제 구현
}
```

### kotlin

```kotlin
// 기본 함수
fun add(a: Int, b: Int): Int {
    return a + b
}

// 단일 표현식 함수 (expression function)
fun add(a: Int, b: Int) = a + b  // 반환 타입 추론

// Unit 함수 (Java의 void와 유사)
fun printMessage(message: String) {
    println(message)
}

// 기본 매개변수 (Default Parameters)
fun greet(name: String, title: String = "Mr."): String {
    return "Hello, $title $name"
}

// Named Arguments로 호출
// greet("John")              // "Hello, Mr. John"
// greet("John", "Dr.")       // "Hello, Dr. John"  
// greet(title = "Ms.", name = "Jane")  // 순서 바꿔도 OK

// 최상위 함수 (클래스 밖에 선언 가능)
fun multiply(a: Int, b: Int) = a * b

// 가변 인자 (Vararg)
fun sum(vararg numbers: Int): Int {
    return numbers.sum()
}

// 고차 함수 (함수를 매개변수로 받음)
fun calculate(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
    return operation(a, b)
}
```

### 주요 차이점

- **fun** 키워드로 함수 선언
- **단일 표현식 함수**: `= ` 사용으로 간결함
- **기본 매개변수**: 오버로딩 없이 기본값 설정
- **Named Arguments**: 가독성과 유연성 증대
- **최상위 함수**: 클래스 없이도 함수 선언 가능

---

## (3) 확장 함수

### java

(불가능)

### kotlin

```kotlin
// String 클래스에 새로운 함수 추가
fun String.isPalindrome(): Boolean {
    return this == this.reversed()
}

// Int에 확장 함수 추가
fun Int.isEven(): Boolean = this % 2 == 0

// List에 확장 함수 추가
fun <T> List<T>.secondOrNull(): T? {
    return if (size >= 2) this[1] else null
}

// 사용 예제
fun main() {
    val word = "level"
    println(word.isPalindrome())  // true - 마치 String의 원래 메서드처럼!
    
    val number = 42
    println(number.isEven())      // true
    
    val list = listOf("a", "b", "c")
    println(list.secondOrNull())  // "b"
}
```

### 주요 차이점

- **기존 클래스 수정 없이 새 기능 추가**
- **점 표기법**으로 자연스러운 호출
- 제네릭도 지원
- **Null safety**와 함께 동작

### 레퍼런스

**[확장함수와 확장속성](https://todaycode.tistory.com/176)**

---

## (4) Null Safety

### java (8+ Optional)

```java
// 전통적인 null 처리
public String getUpperCaseName(Person person) {
    if (person != null && person.getName() != null) {
        return person.getName().toUpperCase();
    }
    return "UNKNOWN";
}

// Optional 사용 (Java 8+)
public Optional<String> findUserEmail(String userId) {
    User user = database.findUser(userId);  // null일 수 있음
    if (user != null) {
        return Optional.of(user.getEmail());
    }
    return Optional.empty();
}

// Optional 체이닝
public String getUserEmailDomain(String userId) {
    return findUserEmail(userId)
            .map(email -> email.split("@")[1])
            .orElse("unknown");
}
```

### kotlin

```kotlin
// Nullable 타입과 Safe call
fun getUpperCaseName(person: Person?): String {
    return person?.name?.uppercase() ?: "UNKNOWN"
}

// Elvis 연산자(?:)로 기본값 제공
fun getUserDisplayName(user: User?): String {
    return user?.name ?: "Anonymous"
}

// Safe call 체이닝
fun getUserEmailDomain(user: User?): String {
    return user?.email?.substringAfter("@") ?: "unknown"
}

// let을 이용한 null 처리
fun processUser(user: User?) {
    user?.let { u ->
        println("Processing user: ${u.name}")
        println("Email: ${u.email}")
    }
}

// 강제 언랩핑(!!) - 주의해서 사용
fun riskyFunction(text: String?) {
    val length = text!!.length  // null이면 KotlinNullPointerException
}

// 스마트 캐스팅
fun smartCastExample(text: String?) {
    if (text != null) {
        // 이 블록 안에서는 text가 자동으로 String으로 캐스팅됨
        println(text.length)  // ?. 없이 사용 가능
    }
}
```

### 주요 차이점

- **컴파일 타임에 null 안전성 보장**
- *`?.` (safe call)**: null이면 전체 체인이 null 반환**
- `?:` (elvis operator)**: null일 때 기본값 제공**
- `!!` (not-null assertion)**: 강제 언랩핑 (위험)**
- 스마트 캐스팅**: null 체크 후 자동 타입 변환

---

## (5) 조건문

### java

```java
// if-else
public String getGrade(int score) {
    if (score >= 90) {
        return "A";
    } else if (score >= 80) {
        return "B";
    } else if (score >= 70) {
        return "C";
    } else {
        return "F";
    }
}

// switch (Java 14+ enhanced switch)
public String getDayType(String day) {
    switch (day) {
        case "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY":
            return "Weekday";
        case "SATURDAY", "SUNDAY":
            return "Weekend";
        default:
            return "Unknown";
    }
}

// 삼항 연산자
public String getStatus(boolean isActive) {
    return isActive ? "Active" : "Inactive";
}
```

### kotlin

```kotlin
// if는 표현식 (expression)
fun getGrade(score: Int): String {
    return if (score >= 90) {
        "A"
    } else if (score >= 80) {
        "B" 
    } else if (score >= 70) {
        "C"
    } else {
        "F"
    }
}

// 더 간결하게
fun getGrade(score: Int) = if (score >= 90) "A" 
                          else if (score >= 80) "B"
                          else if (score >= 70) "C"
                          else "F"

// when 표현식 (switch 대체)
fun getDayType(day: String) = when (day) {
    "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY" -> "Weekday"
    "SATURDAY", "SUNDAY" -> "Weekend" 
    else -> "Unknown"
}

// when with 조건식
fun getTemperatureDescription(temp: Int) = when {
    temp < 0 -> "Freezing"
    temp < 20 -> "Cold"
    temp < 30 -> "Warm"
    else -> "Hot"
}

// when with 타입 체크
fun processValue(value: Any) = when (value) {
    is String -> "Text: $value"
    is Int -> "Number: $value"
    is List<*> -> "List with ${value.size} items"
    else -> "Unknown type"
}
```

### 주요 차이점

- **if와 when은 표현식**: 값을 반환할 수 있음
- **when은 switch보다 강력**: 타입 체크, 범위, 조건식 모두 가능
- **break 문 불필요**: when은 자동으로 break

---

## (6) 반복문

### java

```java
// 전통적인 for 루프
for (int i = 0; i < 10; i++) {
    System.out.println(i);
}

// Enhanced for loop
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}

// while 루프
int count = 0;
while (count < 5) {
    System.out.println(count);
    count++;
}

// Stream API (함수형 스타일)
names.stream()
     .filter(name -> name.length() > 3)
     .map(String::toUpperCase)
     .forEach(System.out::println);
```

### kotlin

```kotlin
// 범위 기반 반복
for (i in 0..9) {        // 0부터 9까지 (포함)
    println(i)
}

for (i in 0 until 10) {  // 0부터 9까지 (10 미포함)
    println(i)
}

for (i in 10 downTo 1) { // 10부터 1까지 역순
    println(i)
}

for (i in 0..20 step 2) { // 0, 2, 4, 6, 8... 20
    println(i)
}

// 컬렉션 반복
val names = listOf("Alice", "Bob", "Charlie")
for (name in names) {
    println(name)
}

// 인덱스와 함께
for ((index, name) in names.withIndex()) {
    println("$index: $name")
}

// while 루프 (동일)
var count = 0
while (count < 5) {
    println(count)
    count++
}

// 함수형 스타일
names.filter { it.length > 3 }
     .map { it.uppercase() }
     .forEach { println(it) }

// repeat 함수
repeat(5) { index ->
    println("Iteration $index")
}
```

### 주요 차이점

- **범위 연산자**: `..`, `until`, `downTo`, `step`
- **구조 분해 할당**: `withIndex()` 등과 함께 사용
- **it 키워드**: 단일 매개변수 람다에서 자동 생성
- **repeat 함수**: 간단한 반복용

---

